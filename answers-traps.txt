It will be important to understand a bit of RISC-V assembly, which you were exposed 
to in 6.004. There is a file user/call.c in your xv6 repo. make fs.img compiles it 
and also produces a readable assembly version of the program in user/call.asm.
===================================================================

Q1. 
Which registers contain arguments to functions? 
For example, which register holds 13 in main's call to printf?
-------------------------------------------------------------------
A1. 
According to calling convention in riscv, registers a0 - a7 
are used as arguments to function. For example, register a2 holds 
the 3rd argument 13 in main's call to printf in call.asm.

===================================================================

Q2. 
Where is the call to function f in the assembly code for main? 
Where is the call to g? (Hint: the compiler may inline functions.)
-------------------------------------------------------------------
A2-1. 
Observe the code snippet in main function below. There is no 
explicit call to function f though f(8)+1 is set as argument 
of printf. Insteadly, the number 12 which equal to f(8)+1 is 
directly set to register a1. This should be the consequence of
optimization by compiler.

void main(void) {
  1c:	1141                	addi	sp,sp,-16
  1e:	e406                	sd	ra,8(sp)
  20:	e022                	sd	s0,0(sp)
  22:	0800                	addi	s0,sp,16
  printf("%d %d\n", f(8)+1, 13);
  24:	4635                	li	a2,13
  26:	45b1                	li	a1,12
  28:	00000517          	auipc	a0,0x0
  2c:	7a850513          	addi	a0,a0,1960 # 7d0 <malloc+0xea>
  30:	00000097          	auipc	ra,0x0
  34:	5f8080e7          	jalr	1528(ra) # 628 <printf>
  exit(0);
  38:	4501                	li	a0,0
  3a:	00000097          	auipc	ra,0x0
  3e:	276080e7          	jalr	630(ra) # 2b0 <exit>
-------------------------------------------------------------------
A2-2. 
Similarly, observe the code snippet of function f and function g.
The content of function f and function g are exactly the same.
This might result from inlining g function.

int g(int x) {
   0:	1141                	addi	sp,sp,-16
   2:	e422                	sd	s0,8(sp)
   4:	0800                	addi	s0,sp,16
  return x+3;
}
   6:	250d                	addiw	a0,a0,3
   8:	6422                	ld	s0,8(sp)
   a:	0141                	addi	sp,sp,16
   c:	8082                	ret

000000000000000e <f>:

int f(int x) {
   e:	1141                	addi	sp,sp,-16
  10:	e422                	sd	s0,8(sp)
  12:	0800                	addi	s0,sp,16
  return g(x);
}
  14:	250d                	addiw	a0,a0,3
  16:	6422                	ld	s0,8(sp)
  18:	0141                	addi	sp,sp,16
  1a:	8082                	ret

===================================================================

Q3.
At what address is the function printf located?
-------------------------------------------------------------------
A3.
The printf is located at virtual address 0x628.

===================================================================

Q4.
What value is in the register ra just after the jalr to printf in main?
-------------------------------------------------------------------
A4.
The value in ra after the jalr to printf in main is 0x38 
which is the next address after jalr.

===================================================================

Q5. 
Run the following code.

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
      
What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. 
If the RISC-V were instead big-endian what would you set i to in order to 
yield the same output? Would you need to change 57616 to a different value?

Here's a description of little- and big-endian and a more whimsical description.
-------------------------------------------------------------------
A5-1.
Result: HE110 World
-------------------------------------------------------------------
A5-2.
If risc-v was big-endian, i should be set as 0x726c6400 
and 57616 keeps unchanged. 

===================================================================

Q6.
In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?

	printf("x=%d y=%d", 3);
-------------------------------------------------------------------
A6. 
The result would be an unknown value stored in register a2. 
Since printf is a variadic function, it uses macro va_arg to 
retrieve arguments. 
The number of va_arg used in printf is determined by number of 
format pattern in input string even though there isn't enough 
argument to fill it.
